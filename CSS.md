
## 水平垂直居中


**flex + justify-content + align-items + height**：给父容器设置 `display: flex`，再通过 `justify-content`**(水平)** 和 `align-items`**(垂直)** 居中。需指定父容器高度，否则垂直居中无效 

**grid + place-items**：父容器内只有一个子元素时，给父容器设置 `display: grid`，再通过 `place-items:center` 同时设置水平居中和垂直居中，也需要指定父容器高度

**定位 + margin**：子元素宽高固定，通过绝对定位和 `margin: auto` 实现。父容器设置 `position: relative`，子容器设置 `position: absolute`，再通过 `margin: auto` 实现居中，子元素必须指定宽高

**定位 + transform**：子元素宽高不固定，通过绝对定位和 `transform` 偏移实现居中。父容器设置 `position: relative`，子容器设置 `position: absolute`，再通过 `margin: auto` 实现居中，子元素必须指定宽高


## BEM （Block Element Modifier）


BEM （Block Element Modifier）是一种 CSS 命名方法论，旨在通过约定类名结构，提高样式的可维护性、可读性和避免类名冲突


### 什么是“BEM 类名冲突”？

严格来说，**正确使用 BEM 时，几乎不会发生类名冲突**。  
所谓“BEM 类名冲突”，通常是指：

> **开发者没有遵循 BEM 规范命名，导致不同组件或模块的 CSS 类名重复，从而意外覆盖样式。**

换句话说，“BEM 类名冲突”其实 **不是 BEM 本身的问题，而是误用或未严格遵守 BEM 规则导致的副作用**。


**BEM 命名规则**

BEM 的类名结构为：
```css
.block { }                     /* 块（独立组件） */
.block__element { }            /* 元素（属于某个块的组成部分） */
.block--modifier { }           /* 修饰符（块或元素的变体状态） */
```

**例如：**

**所有类名都以块名作为前缀**，天然形成命名空间，避免与其他组件冲突。

```html
<!-- 一个“按钮”组件 -->
<button class="button">普通按钮</button>
<button class="button button--primary">主按钮</button>

<!-- 一个“菜单”组件 -->
<nav class="menu">
  <ul class="menu__list">
    <li class="menu__item menu__item--active">首页</li>
  </ul>
</nav>
```


#### 冲突原因

- 块名设计不合理：不同模块可能使用相同块名，导致全局冲突

- 嵌套层级混乱：错误地将块嵌套作为命名依据（如 `header__nav__item`），违反 BEM “元素不嵌套” 的原则（元素仅属于某一块，与层级无关），导致命名冗长且易与其他模块的同类元素重名

- 修饰符滥用：修饰符命名过于简单（如 `--active`、`--big`），在不同块中可能重复

**冲突例子：**

```css
/* ❌ 错误：全局使用通用名 */
.title { color: red; }
.item { padding: 10px; }

/* ❌ 风险高：块名过于常见 */
.header__logo { ... }
.footer__logo { ... }

/* ❌ 不推荐：元素嵌套元素 */
.card__header__title { ... }
```

```html 
/* 混用 BEM 与非 BEM 类名 */
<div class="card highlight">...</div>
```

#### 解决方法

- 块名添加前缀：为块名增加项目或模块前缀，明确归属，避免通用名称冲突

- 严格遵循BEM命名规则，避免元素嵌套命名

- 修饰符绑定具体块，避免全局通用修饰符： `button--active`

- 使用 *CSS Module*（哈希类名+局部作用域）



## CSS Module 

**CSS Modules** 是一种**将 CSS 类名局部作用域化（Scoped Locally）的技术，主要用于在组件化开发（如 React、Vue、Angular 等）中**避免全局样式污染和类名冲突**。

**原理：局部作用域、类名唯一化**

**工作流程：**

1. **类名的 "局部化" 标记**：在 CSS Module 中，所有类名默认被视为 "局部作用域"（区别于普通 CSS 的全局作用域）。构建工具会将 CSS 文件中的类名（如 `.button`）标记为 "需要被处理的局部类名"，而通过 `:global()` 包裹的类名（如：`:global(.reset)`）则被标记为 "全局类名"，无需特殊处理

2. **类名的 "唯一化" 编译**：构建工具（通过 `css-loader` 等 loader）会对 "局部类名" 进行 **哈希转换** ，生成全局唯一的类名字符串

3. **类名映射与组件引用**：编译过程中，构建工具会同时生成一个 "类名映射表"（通常是 JSON 对象），记录 "原类名" 与 "哈希后类名" 的对应关系。在组建中引入 CSS Module 文件时，实际导入的就是这个映射表，开发者通过映射表的属性名使用样式，确保引用的是哈希后的唯一类名。


**如何工作：**

1. 在构建时（如 Webpack 、Vite），将 CSS 文件中的类名**自动转换为唯一的哈希值**；
2. JS 文件通过 `import` 引用这些类名，获得映射后的唯一名称；
3. 最终 HTML 中使用的是**不会冲突的全局唯一类名**。


**技巧**：

组合（Composition）----- 复用样式

```css
/* utils.module.css */
.primaryBtn {
  background: blue;
  color: white;
  padding: 8px 16px;
}

/* Button.module.css */
.primary {
  composes: primaryBtn from './utils.module.css';
  border-radius: 4px;
}
```


## 预编译

`CSS` 预编译语言在前端里有三大优秀的预编译处理器：

1. sass
2. less
3. stylus

### 为什么会出现这些预编译处理器

#### 1. 原生 CSS 的核心痛点

1. 缺乏编程特性：无法使用变量（如统一管理主题色）、函数（如动态计算尺寸）、条件判断（如不同屏幕尺寸的样式分支），导致重复代码多、维护困难。

 2. 无模块化组织能力：原生 CSS 没有 “导入 / 导出” 机制，大型项目中样式文件只能通过 `<link>` 全局引入，易出现类名冲突、依赖混乱。

3. 嵌套能力弱：原生 CSS 选择器嵌套需要重复书写父级（如 `.nav .item .link`），代码冗长且层级关系不直观。

4. 兼容性处理繁琐：针对不同浏览器的前缀（如 `-webkit-`、`-moz-`）需要手动重复书写，效率低。


#### 2. 使用预编译处理器提升开发效率与可维护效率


1. 1. 引入编程特性：

	 - 变量（`$color: #333`）：统一管理主题色、字体大小等，修改时 “一处改、处处生效”；

     - 混合（Mixin）：封装重复样式（如按钮样式、清除浮动），通过 `@include` 复用，减少冗余；

	- 函数 / 运算：动态计算（如 `width: 100% - 20px`）、颜色处理（如 `darken(#fff, 10%)` 生成深色）。    

2. 强化代码组织：

	 - 嵌套语法：通过缩进表示层级（如 `.nav { .item { color: red; } }`），替代冗长的后代选择器，结构更清晰；
 
	- 模块化导入：通过 `@import` 拆分样式文件（如 `_header.scss`、`_footer.scss`），按需组合，避免全局污染风险。

3. 自动化兼容性处理： 内置工具（如 Sass 配合 Autoprefixer）可自动生成浏览器前缀，无需手动书写 `-webkit-` 等，适配多端更高效。


#### 3. 多样化原因: 技术选型的场景差异与历史演进   


1. 解决问题的侧重点不同：
    
	 - **Sass**：功能最全面（支持变量、Mixin、函数、条件语句等），生态成熟，适合大型项目（如 Bootstrap 基于 Sass 开发）；
    
	- **Less**：语法更接近原生 CSS，学习成本低，早期与 Bootstrap 结合紧密，适合快速上手的中小型项目；
    
	-  **Stylus**：语法极简（可省略括号、分号），灵活性高，适合追求代码简洁的团队（如 Node.js 生态的项目）。

2. 历史发展与社区生态：

	- Sass 诞生最早（2006 年），基于 Ruby 开发，早期因 Ruby 环境门槛限制了普及；后来推出 SCSS 语法（兼容 CSS）并迁移到 Dart，生态逐渐成为主流。    

	- Less 紧随其后（2009 年），基于 JavaScript 开发，早期因与前端工具链（如 Webpack）集成更顺畅，在前端社区快速流行。

	 - 不同团队在各自技术栈中选择顺手的工具，形成了多样化的生态。



## CSS-in-JS

将 CSS 样式直接编写在 JavaScript 代码中的技术方案，核心思想是 “将样式与组件逻辑紧密结合”，通过 JavaScript 动态生成和管理 CSS


**原理**：

通过 *JavaScript 函数或对象描述样式*，再由框架在运行时或编译时将其转换为实际的 CSS 规则，并注入到页面中。让组件的样式逻辑（如动态主题、条件样式）与组件的业务逻辑共存，避免 “样式文件与组件文件分离” 导致的维护成本。通过动态生成唯一类名或属性选择器，确保组件样式不会污染全局，天然解决类名冲突问题。

```css
// Button.jsx
const Button = () => (
  <button
    style={{
      background: 'blue',
      color: 'white',
      padding: '8px 16px',
      borderRadius: '4px'
    }}
  >
    Click
  </button>
);
```


**优点**：

1. _样式与组件高度内聚_：样式随组件定义，无需切换文件查找。

2. _动态样式更灵活_：直接通过 JS 变量、props、状态（如 `useState`）控制样式（如 `color: ${isActive ? 'red' : 'gray'}`），比原生 CSS 变量更直观。

3. _天然样式隔离_：自动生成唯一类名，无需手动管理 BEM 或 CSS Module，彻底避免全局污染。

4. _更好的_ _JS_ _集成能力_：可直接使用 JS 的函数、条件、循环等逻辑处理样式（如动态生成渐变颜色、计算尺寸），扩展性强。

**缺点**：

1. _学习成本_：需要学习特定库的语法（如 styled-components 的模板字符串规则），不同于原生 CSS 或预处理器。

2. _性能损耗_：运行时转换的库（如 styled-components）会增加 JS 执行时间和内存占用，复杂页面可能导致性能下降。

3. _调试体验较差_：生成的哈希类名（如 `css-123xyz`）不直观，难以定位对应的组件样式（需依赖工具如 React DevTools 插件）。

4. _与_ _CSS_ _生态兼容性弱_：无法直接使用传统 CSS 工具（如 PostCSS 插件、CSS 预处理器的部分功能），迁移成本高。


### styled-components

目前最流行的 **CSS-in-JS 库之一**，核心思想是 “**将 CSS 样式与 React 组件完全绑定**”，通过 “样式即组件” 的模式，让样式开发更贴近组件化思维。它的设计初衷是解决传统 CSS 的全局污染、样式与组件分离等问题，同时简化动态样式的实现。


**原理**：

通过模板字符串定义样式，动态生成带唯一类名的 React 组件


**关键特性：**

1. _样式与组件的深度耦合_ 样式直接定义在组件内部，无需单独的 CSS 文件，解决了 “样式文件与组件文件分离” 导致的维护难题（如改样式需同时找两个文件）。

2. _动态样式的简化实现_ 支持通过组件 props 直接控制样式（如示例中的 `primary` 属性），比传统的 “类名切换” 更直观，尤其适合主题切换、状态样式（如 `disabled`、`active`）等场景。

3. _自动样式隔离_ 自动生成全局唯一的类名，避免传统 CSS 的类名冲突问题，无需手动维护 BEM 命名或 CSS Module。

4. _嵌套语法与伪类支持_ 支持类似 SCSS 的嵌套写法（如 `&:hover`、`& > span`），以及伪元素（`&::before`），保持 CSS 开发者熟悉的语法习惯。

5. _主题（Theming）机制_ 通过 `ThemeProvider` 实现全局主题配置，组件内可直接访问主题变量，轻松实现明暗模式切换

6. _继承与扩展_ 支持通过 `styled(组件)` 继承已有样式并扩展，减少代码冗余：